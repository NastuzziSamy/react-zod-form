<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Recommended Setup Tips</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="recommended-setup-tips">Recommended Setup Tips</h1>
<h2 id="tips">Tips</h2>
<p>For most projects, the following approach will work well</p>
<h2 id="tip-1-create-a-custom-form-component">Tip 1. Create a custom form component</h2>
<p>Creating a custom form container is recommended for DRYness. For example:</p>
<pre><code class="language-tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FormContainer</span>(<span class="hljs-params">{
  onSubmit,
  children,
  loading,
}: {
  onSubmit: () =&gt; <span class="hljs-keyword">void</span>;
  children: ReactNode;
  loading?: boolean;
}</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;space-y-4&quot;</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{onSubmit}</span>&gt;</span>
      {children}
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;mt-4 w-full&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">{loading}</span>&gt;</span>
        Submit
      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// Make sure to pass it to `createZodForm`</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Form</span> = <span class="hljs-title function_">createZodForm</span>(mapping, { <span class="hljs-title class_">FormComponent</span>: <span class="hljs-title class_">FormContainer</span> });
</code></pre>
<p>The above form component has a &quot;loading&quot; prop to show a loading spinner while the form is submitting to make it easy for us to code a great UX. Also notice the form component has a <code>space-y-4</code>, ensuring consistent spacing between form components.</p>
<h2 id="2-consider-creating-custom-components-per-text-field-type">2. Consider creating custom components per text field type</h2>
<p>There are many different types of text fields we may want to implement. For example, a phone input might behave differently than a password input. If you're buildling custom behavior per input types, consider using a different Schema per input:</p>
<pre><code class="language-tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">PhoneSchema</span> = <span class="hljs-title function_">createUniqueFieldSchema</span>(
  z.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">regex</span>(<span class="hljs-regexp">/[0-9]{10}/</span>),
  <span class="hljs-string">&quot;phone&quot;</span>
);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">PasswordSchema</span> = <span class="hljs-title function_">createUniqueFieldSchema</span>(
  z.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">min</span>(<span class="hljs-number">8</span>, <span class="hljs-string">&quot;Must be 8 characters in length&quot;</span>),
  <span class="hljs-string">&quot;password&quot;</span>
);

<span class="hljs-keyword">const</span> mapping = [
  [z.<span class="hljs-title function_">string</span>(), <span class="hljs-title class_">TextField</span>],
  [<span class="hljs-title class_">PhoneSchema</span>, <span class="hljs-title class_">PhoneField</span>],
  [<span class="hljs-title class_">PasswordSchema</span>, <span class="hljs-title class_">PasswordField</span>],
] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;
</code></pre>
<h3 id="component-composition--wrapper-components">Component Composition / Wrapper Components</h3>
<p>Since we probably want to share some styling and such across these similar types of fields, we can use a base controlled component as a child of the components passed to the mapping, and the components passed to the mapping would be &quot;wrappers&quot; for this inner base text field component:</p>
<pre><code class="language-tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TextFieldBase</span>(<span class="hljs-params">{
  label,
  value,
  onChange,
  error,
  inputProps,
}: {
  value: string;
  onChange: (value: string) =&gt; <span class="hljs-keyword">void</span>;
  label?: string;
  error?: string;
  inputProps?: Omit&lt;ComponentProps&lt;<span class="hljs-string">&quot;input&quot;</span>&gt;, <span class="hljs-string">&quot;onChange&quot;</span> | <span class="hljs-string">&quot;value&quot;</span>&gt;;
}</span>) {
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>{label}<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
      <span class="hljs-attr">className</span>=<span class="hljs-string">{/*</span> <span class="hljs-attr">custom</span> <span class="hljs-attr">input</span> <span class="hljs-attr">styles</span>*/}
      <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span>
      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> {
        onChange(e.target.value);
      }}
      {...inputProps}
    /&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{error}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">TextField</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> {
    <span class="hljs-attr">field</span>: { onChange, value },
    error,
  } = useZodController&lt;string&gt;();
  <span class="hljs-keyword">const</span> { label } = <span class="hljs-title function_">useDescription</span>();

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextFieldBase</span>
      <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span>
      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{onChange}</span>
      <span class="hljs-attr">label</span>=<span class="hljs-string">{label}</span>
      <span class="hljs-attr">error</span>=<span class="hljs-string">{error?.errorMessage}</span>
    /&gt;</span></span>
  );
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">PhoneField</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> {
    <span class="hljs-attr">field</span>: { onChange, value },
    error,
  } = useZodController&lt;string&gt;();
  <span class="hljs-keyword">const</span> { label } = <span class="hljs-title function_">useDescription</span>();

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextFieldBase</span>
      <span class="hljs-attr">value</span>=<span class="hljs-string">{maskPhone(value)}</span>
      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(value)</span> =&gt;</span> onChange(unmaskPhone)}
      label={label}
      error={error?.errorMessage}
    /&gt;</span>
  );
}
</code></pre>
<p>In simple cases this may not be necessary, and may be easier to just pass props to the same TextField component. But if the input components are very different from eachother, we can save passing a lot of props by creating these types of wrappers. If you're using a component library like MUI or Mantine, you likely won't need to define <code>TextFieldBase</code> yourself, and should instead use the TextField component from the component library</p>

            
            
        </body>
        </html>